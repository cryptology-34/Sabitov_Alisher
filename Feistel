import os
def F(r, k, nbits):
    data = (r * int.from_bytes(k, 'big')) ^ (r << 3) ^ (r >> 5)
    data = data & ((1 << nbits) - 1)
    return data

def feistel_encrypt(block, bits, keys):
    half = bits // 2
    mask = (1 << half) - 1
    L = block >> half
    R = block & mask
    for k in keys:
        L, R = R, L ^ F(R, k, half)
    return (L << half) | R

def feistel_decrypt(block, bits, keys):
    half = bits // 2
    mask = (1 << half) - 1
    L = block >> half
    R = block & mask
    for k in reversed(keys):
        prev_R = L
        prev_L = R ^ F(prev_R, k, half)
        L, R = prev_L, prev_R
    return (L << half) | R

def add_padding(data, block_size_bytes=4):
    padding_len = block_size_bytes - (len(data) % block_size_bytes)
    if padding_len == 0:
        padding_len = block_size_bytes
    padding = bytes([padding_len] * padding_len)
    return data + padding

def remove_padding(data):
    if len(data) == 0:
        return data
    padding_len = data[-1]
    if padding_len > len(data):
        raise ValueError("Invalid padding")
    for i in range(1, padding_len + 1):
        if data[-i] != padding_len:
            raise ValueError("Invalid padding")
    return data[:-padding_len]

def encrypt_data(data, keys, block_bits=32):
    if isinstance(data, str):
        data = data.encode('utf-8')
    padded_data = add_padding(data)
    encrypted_blocks = []
    for i in range(0, len(padded_data), block_bits // 8):
        block_bytes = padded_data[i:i + block_bits // 8]
        if len(block_bytes) < block_bits // 8:
            block_bytes = block_bytes.ljust(block_bits // 8, b'\x00')
        block = int.from_bytes(block_bytes, 'big')
        encrypted_block = feistel_encrypt(block, block_bits, keys)
        encrypted_blocks.append(encrypted_block)
    return encrypted_blocks

def decrypt_data(encrypted_blocks, keys, block_bits=32):
    decrypted_bytes = bytearray()
    for block in encrypted_blocks:
        decrypted_block = feistel_decrypt(block, block_bits, keys)
        decrypted_bytes.extend(decrypted_block.to_bytes(block_bits // 8, 'big'))
    return remove_padding(bytes(decrypted_bytes))

def write_encrypted_to_file(encrypted_blocks, filename):
    with open(filename, 'wb') as f:
        for block in encrypted_blocks:
            f.write(block.to_bytes(4, 'big'))

def read_encrypted_from_file(filename):
    encrypted_blocks = []
    with open(filename, 'rb') as f:
        while True:
            chunk = f.read(4)
            if not chunk:
                break
            block = int.from_bytes(chunk, 'big')
            encrypted_blocks.append(block)
    return encrypted_blocks

if __name__ == "__main__":
    block_bits = 32
    keys = [b"r1", b"r2", b"r3", b"r4"]
    print("=== Тест без падинга ===")
    plain = 0xDEADBEEF & ((1 << block_bits) - 1)
    cipher = feistel_encrypt(plain, block_bits, keys)
    decr = feistel_decrypt(cipher, block_bits, keys)
    print("Plain :", hex(plain))
    print("Cipher:", hex(cipher))
    print("Decr  :", hex(decr), "OK?", decr == plain)
    print("\n=== Тест с падингом и файлами ===")
    test_message = "Hello, this is a secret message for Feistel network!"
    print(f"Исходное сообщение: '{test_message}'")
    
    encrypted_blocks = encrypt_data(test_message, keys)
    print(f"Зашифровано блоков: {len(encrypted_blocks)}")
    
    filename = "encrypted_data.bin"
    write_encrypted_to_file(encrypted_blocks, filename)
    print(f"Данные записаны в файл: {filename}")
    
    encrypted_from_file = read_encrypted_from_file(filename)
    print(f"Прочитано блоков из файла: {len(encrypted_from_file)}")
    
    decrypted_data = decrypt_data(encrypted_from_file, keys)
    decrypted_text = decrypted_data.decode('utf-8')
    print(f"Расшифрованное сообщение: '{decrypted_text}'")
    print(f"Сообщение корректно: {test_message == decrypted_text}")
    
    print(f"\nРазмер файла {filename}: {os.path.getsize(filename)} байт")
    
    if os.path.exists(filename):
        os.remove(filename)
        print(f"Файл {filename} удален")
